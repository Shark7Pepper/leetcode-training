# 1. 两数之和
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例:
```
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```
## 1.1. C
```C
int* twoSum(int* nums, int numsSize, int target){
    int *a = (int*)malloc(2*sizeof(int));
    for(int i = 0; i< numsSize-1;i++)
    {
        for(int j = i+1;j<numsSize;j++)
        {
            if(nums[i]+nums[j] == target)
            {
                a[0]=i;
                a[1]=j;
                return a;
            }
        }
    }
    return NULL;
}
```
## 1.2. C++
```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> map;
        for (int i = 0; i < nums.size(); i ++) {
            if(map.count(target - nums[i]) == 1) 
            {
               return {map[target - nums[i]], i};//key值    
            }
            map[nums[i]] = i; //<nums[i],i>,第一个为key值，第二个为value
        }
        return {};
    }
};
```
# 2. 两数相加
给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例
```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```
## 2.1. C
```
struct ListNode {
     int val;
    struct ListNode *next;
 };
 
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){

}
```

## 2.2. C++
```C++
 Definition for singly-linked list.
 struct ListNode {
     int val;
     ListNode *next;
     ListNode(int x) : val(x), next(NULL) {}
 };

public class Solution
{
    public ListNode AddTwoNumbers(ListNode l1, ListNode l2)
    {
        int carry = 0;
        ListNode listNode= new ListNode(0);
        ListNode p1 = l1, p2 = l2, p3 = listNode;

        while (p1 != null || p2 != null)
        {
            if (p1 != null)
            {
                carry += p1.val;
                p1 = p1.next;
            }
            if (p2 != null)
            {
                carry += p2.val;
                p2 = p2.next;
            }
            p3.next = new ListNode(carry % 10);
            p3 = p3.next;
            carry /= 10;
        }
        if (carry == 1)
            p3.next = new ListNode(1);
        return listNode.next;
    }
}
```
# 3. 无重复字符的最长子串
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例1：
```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
示例 2:
```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```
示例 3:

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```
## 3.1. C
```C
int lengthOfLongestSubstring(char * s){
    int start = 0, end = 0, maxlen = 0;
    char map[256] = {0};
    map[(int)*(s+start)] = 1;

    while( *(s+end) != 0 )
    {
        maxlen = maxlen>(end-start+1)?maxlen:(end-start+1);
        ++end;
        while( 0 != map[ (int)*(s+end) ] )//将要加入的新元素与map内元素冲突
        {
            map[ (int)*(s+start) ] = 0;
               ++start;
        }
        map[(int)*(s+end)] = 1;
    }

    return maxlen;
}
```
## 3.2. C++
**滑窗**
```C++
class Solution{
public:
    int lengthOfLongestSubstring(string s)
    {
        unorderd_set<char> occ;
        int n = s.size();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int rk=-1,ans=0;
        // 枚举左指针的位置，初始值隐性地表示为 -1
        for(int i =0;i < n; ++i){
            if(i != 0){
                // 左指针向右移动一格，移除一个字符
                occ.erase(s[i-1]);
            }
            while(rk+1 < n && !occ.count(s[rk+1])){
                // 不断地移动右指针
                occ.insert(s[rk+1]);
                ++rk;
            }
            // 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = max(ans,rk-i+1);
        }
        return ans;
    }
}
```
知识点：关联容器`unordered_set` 内部实现是`基于哈希表`，哈希表是根据关键码值而进行直接访问的数据结构，通过相应的哈希函数(也称散列函数)处理关键字得到相应的关键码值，关键码值对应着一个特定位置，用该位置来存取相应的信息，这样就能以较快的速度获取关键字的信息。`unordered_set内部解决冲突采用的是----链地址法`，当用冲突发生时把具有同一关键码的数据组成一个链表。
# 4. 最长回文子串
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

注：回文的意思是正着念和倒着念一样，例如：上海自来水来自海上。


示例 1：
```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```
示例 2：
```
输入: "cbbd"
输出: "bb"
```
## 4.1. C++
```C++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n));
        string ans;
        for (int l = 0; l < n; ++l) {
            for (int i = 0; i + l < n; ++i) {
                int j = i + l;
                if (l == 0) {
                    dp[i][j] = 1;
                }
                else if (l == 1) {
                    dp[i][j] = (s[i] == s[j]);
                }
                else {
                    dp[i][j] = (s[i] == s[j] && dp[i + 1][j - 1]);
                }
                if (dp[i][j] && l + 1 > ans.size()) {
                    ans = s.substr(i, l + 1);
                }
            }
        }
        return ans;
    }
};
```
# 5. Z 字形变换
将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，排列如下：
```
L   C   I   R
E T O E S I I G
E   D   H   N
```
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："LCIRETOESIIGEDHN"。
请你实现这个将字符串进行指定行数变换的函数：
```
string convert(string s, int numRows);
```

示例 1:
```
输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"
```
示例 2:
```
输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:
L     D     R
E   O E   I I
E C   I H   N
T     S     G
```
思路：当前行数是0或者n-1的时候变换上下方向(n为指定行数)
## 5.1. C++
```C++
class Solution
{
public:
    string convert(string s, int numRows)
    {
        if(numRows == 1)
        {
            return s;
        }
        int sSize = int(s.size());
        int storeSize = min(sSize,numRows);
        string result;
        vector<string> rows(storeSize);
        int curRow = 0;
        //初始有一次更改change值，因此初始值为false
        bool change = false;
        for(char c:s){
            //将第n行的值存在rows[n]中
            rows[curRow] += c;
            if(curRow == 0 || curRow == numRows-1){
                change = !change;
            }
            curRow += change? 1:-1;
        }
        string ret;
        for(string row : rows){
            ret += row;
        }
        return ret;
    }
}
```
知识点：对于string的for循环遍历
```
//处理每个字符串（遍历每个字符串，且对单个字符不做修改，只做判断）基于范围的for语句（C++11新标准）
string str;
for(auto c:str) //c是变量，用于访问str中每一个元素，每次迭代c会初始化为str中的下一个元素；str字符串序列
{ 循环题 }

//处理每个字符串（需要对某些字符做出修改）：如果要改变string对象中字符的值，则必须把循环中的变量定义为引用类型
string str;
for(auto &c:str) //c是变量，用于访问str中每一个元素，每次迭代c会初始化为str中的下一个元素；str字符串序列
{ 循环题 }
```
# 6. 整数反转
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
示例 1:
```
输入: 123
输出: 321
```
示例 2:
```
输入: -123
输出: -321
```
示例 3:
```
输入: 120
输出: 21
```
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。
## 6.1. C++
为了便于解释，我们假设**rev**是正数。
* 如果temp=rev*10 +pop导致溢出，那么一定有 rev>=INT_MAX/10;
* 如果rev>INT_MAX/10，那么temp=rev*10+pop一定会溢出;
* 如果rev==INT_MAX/10，那么只要pop>7,temp=rev*10+pop就会一出。
同理rev为负数逻辑相同。

```C++
class Solution{
public:
    int reverse(int x){
        int rev = 0;
        while(x!=0){
            //取出最后一位
            int pop=x%10;
            x/=10;
            if(rev > INT_MAX/10 || (rev== INT_MAX/10 && pop>7)) return 0;
            if(rev > INT_MIN/10 || (rev== INT_MIN/10 && pop>-8)) return 0;
            rev =rev*10 +pop;
        }
        return rev;
    }
}
```
注：C中int类型是32位的，范围是-2147483648到2147483647 。
标准头文件`limits.h`有定义
```
#define INT_MAX 2147483647
#define INT_MIN (-INT_MAX - 1)
```
# 7. 字符串转换整数(atoi)
规则如下：
* 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
* 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
* 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0 。
* 本题中的空白字符只包括空格字符 ' ' 。
* 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。
示例 1:
```
输入: "42"
输出: 42
```
示例 2:
```
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```
示例 3:
```
输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```
示例 4:
```
输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
```
示例 5:
```
输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。
```

```C
int myAtoi(char * str){
    static const int MAX_INT = (int)((unsigned)~0 >> 1);
    static const int MIN_INT = -(int)((unsigned)~0 >> 1) - 1;
    unsigned int n = 0;

    //判断是否输入为空
    if (str == 0)
    {
        return 0;
    }

    //处理空格
    while (isspace(*str))
        ++str;

    //处理正负
    int sign = 1;
    if (*str == '+' || *str == '-')
    {
        if (*str == '-')
            sign = -1;
        ++str;
    }

    //确定是数字后才执行循环
    while (isdigit(*str))
    {
        //处理溢出
        int c = *str - '0';
        if (sign > 0 && (n > MAX_INT / 10 || (n == MAX_INT / 10 && c > MAX_INT % 10)))
        {
            n = MAX_INT;
            break;
        }
        else if (sign < 0 && (n >(unsigned)MIN_INT / 10 || (n == (unsigned)MIN_INT / 10 && c > (unsigned)MIN_INT % 10)))
        {
            n = MIN_INT;
            break;
        }

        //把之前得到的数字乘以10，再加上当前字符表示的数字。
        n = n * 10 + c;
        ++str;
    }
    return sign > 0 ? n : -n;
}
```
# 8. 回文数
判断一个整数是否是回文数。
示例 1:
```
输入: 121
输出: true
```
示例 2:
```
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```
示例 3:
```
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```
思路：
考虑只反转int 数字的一半。毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。
由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。
## 8.1. C/C++
```C++
class Solution
{
public:
    bool isPalindrome(int x){
        // 特殊情况：
        // 如上所述，当 x < 0 时，x 不是回文数。
        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
        // 则其第一位数字也应该是 0
        // 只有 0 满足这一属性
        if(x<0 || (x%10==0 && x!=0)){
            return false;
        }
        int reverteNumber = 0;
        while(x > revertedNumber){
            revertedNumber = revertedNumber*10 +x%10;
            x/=10;
        }
        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
        return x==revertedNumber || x == revertedNumber/10;
    }
}
```
# 9. [盛最多水的容器](algorithm/盛最多水的容器.md)
# 10. [最长公共前缀](algorithm/最长公共前缀.md)
# 11. [三数之和](algorithm/三数之和.md)
# 12. [最接近的三数之和](algorithm/最接近的三数之和.md)
# 13. [电话号码的字母组合](algorithm/电话号码的字母组合.md)
# 14. [四数之和](algorithm/四数之和.md)
